---
title: "Dependencies in Practice"
author: "Joe Shaw"
format: html
---

I've combined notes from chapters 9, 10 and 11 to explain this to myself. One confusing aspect is that several verbs which might seem synonymous actually have specific meanings: import, load, install, attach and depend. The other key distinction is between the DESCRIPTION and the NAMESPACE file and what each does.

# Installing Packages into a Package

From the previous chapter ("Dependencies"):

- **Loading**: loading a package loads the package code and data so that they are available in computer memory. But the package is not in the search path, so you need to use the :: operator to call functions.

- **Attaching**: attaching the package puts the package in the search path, so you can call functions without ::. You have to first load a package before you can attach it.

When you execute library(), a package is loaded and then attached.

# DESCRIPTION and NAMESPACE

The DESCRIPTION file is different to the NAMESPACE file. The DESCRIPTION file can be modified by hand, or using the usethis() function which automatically adds packages to the DESCRIPTION file. The NAMESPACE file isn't modified by hand and instead is automatically generated by roxygen2 based on information in function documentation.

My understanding is:

- DESCRIPTION lists the packages on which your package depends at a zoomed-out level.

- NAMESPACE lists the specific functions from other packages.

# namespace and NAMESPACE

namespace: the internal environment of the package

NAMESPACE: the file which specifies the package's namespace environment 

# Declaring Dependencies in DESCRIPTION

When you build a package, it will probably use things that depend on other packages (dependencies). You specify the packages that your packages uses in the DESCRIPTION file. 

You can specify them using:

- **Imports**: packages which are needed

- **Suggests**: packages which might be useful for the user for optional functionality.

- **Depends**: another form of Imports which it is not recommended to use. "The main difference is that a package you list in Imports will just be loaded when you use it, whereas a package you list in Depends will be attached when your package is attached. Unless there is a good reason otherwise, you should always list packages in Imports not Depends. That’s because a good package is self-contained, and minimises changes to the global landscape, including the search path." (Chapter 10)

This means I'll focus on the Imports option, because that is the most appropriate for what I need.

# Using Dependencies

"Packages listed in [DESCRIPTION] Imports are needed by your users at runtime and will be installed (or potentially updated) when users install your package via install.packages()."

"It is natural to assume that listing a package in Imports actually “imports” the package, but this is just an unfortunate choice of name for the Imports field. The Imports field makes sure that the packages listed there are installed when your package is installed. It does not make those functions available to you, e.g. below R/, or to your user." 

This is relevant in the next section - packages mentioned in DESCRIPTION aren't automatically available when you're building a package. Example: specifying "Imports: stringr" in your DESCRIPTION file doesn't mean you can just call str_c() in an R file in your R folder.

# Importing

These are some names to avoid confusion when talking about packages within packages, or packages requiring packages:

- pkg: the name of the package that you are building

- aaapkg: the name of a hypothetical package which pkg depends on

- aaa_fun(): the name of a function exported by aaapkg

If aaapkg is listed in "Imports" in the DESCRIPTION file of pkg, the code inside pkg can assume that aaapkg is installed whenever pkg is installed.

## The way to do it

The recommended way to do things is to call external functions using the package::function() syntax.

For example, you can call the aaa_fun() function from aaapkg in some R code saved in the R folder of pkg.

```{r}
#| label: call-a-function
#| eval: FALSE
#| include: TRUE

somefunction <- function(...) {
  #' @importFrom aaapkg aaa_fun
  #' @export
  
  x <- aaapkg::aaa_fun(...)
  ...
}

```
The @importFrom aaapkg aaa_fun roxygen2 comment shows that you need to have this function imported for pkg to work.

By including @importFrom aaapkg aaa_fun and calling aaapkg::aaa_fun you are specifically saying "use the aaa_fun function from aaapkg which should be loaded whenever pkg is loaded". When pkg is built, the NAMESPACE file will be updated to reflect this by saying "importFrom(aaapkg,aaa_fun)".

Just for clarity (because I find it confusing):

- DESCRIPTION file: "Imports: aaapkg"

- NAMESPACE file: "importFrom(aaapkg,aaa_fun)"

- roxygen documentation: "@importFrom aaapkg aaa_fun"

## The way not to do it

"Specifically, we recommend that you default to not importing anything from aaapkg into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future."

What I think this means is: don't call things into R scripts using library() and then call functions without the :: operator.

```{r}
#| label: call-a-function-2
#| eval: FALSE
#| include: TRUE

library(aaapkg)

# File in R folder
somefunction <- function(...) {
  ...
  x <- aaa_fun(...)
  ...
}

```

If you looked at the NAMESPACE file in this case, I think it would just say "import(aaapkg)". That's ok, but it doesn't tell you which functions from aaapkg you are using, which might be confusing if you are looking at your pkg in future.

There is more detail on why you shouldn't call packages with library() in Chapter 6.

# Exporting

"Export functions that you want other people to use. **Exported functions must be documented**, and you must be cautious when changing their interface — other people are using them!"

"That said, if you’re creating a package for yourself, it’s far less important to be this disciplined. Because you know what’s in your package, it’s fine to have a local “miscellany” package that contains a hodgepodge of functions that you find useful. But it is probably not a good idea to release such a package for wider use."
