---
title: "Part Two"
author: "Joe Shaw"
format: html
editor: visual
---

"Using the tools described in part two of this book, we can actually set up the project, right from the very beginning, in a way that it will be reproducible quite naturally. "

Docker solves the issue of installing older packages.

# 9: Rewriting our project

Turn scripts into markdown documents.

Literate programming has the advantage over code comments in that it can include much more context and detail.

The general format is:
- Explain what you're doing
- Write a function
- Use that function

knitr::knit_child creates a child document.

This is really helpful if you want to have lots of code chunks which are formatted in the same way (a plot for dataset1, the same plot for dataset 2 etc).

# 10: Freezing packages

"At a minimum, {renv} ensures that a project’s library doesn’t interfere with another project’s library while you’re working on different projects."

renv alone is not enough to ensure reproducibility - it gives a list of which versions of packages you used, but in practice it can be really hard to install old package versions and recreate the exact environment.

# 11: Packaging your code

The term fusen comes from origami - flat paper is inflated to create a box shape.

"Write it down, write it down, write it down… you’re already documenting and testing things (most of the time in the console only), so why not just write it down once and for all, so you don’t have to rely on your ageing, mushy brain so much?"

"My very personal take on licenses is that you should use copyleft licenses as much as possible (so licenses like the GPL) which ensure that if others take your code and change it, their changes also have to be republished to the public under the GPL – but only if they wish to publish their changes at all."

"licenses like the MIT allow private companies to take open source and freely available code and incorporate it inside their own proprietary tools, without having to give back their modifications to the community."

Example: Andrew S. Tanenbaum built an OS called MINIX and released it under a permissive licence. Intel then took MINIX, modified it, and sold it within their new chips - open-source code had been used to make a profit for a private company.

"You can always access a “private” function by using ::: (three times the :), as in package:::private_function()."

fusen uses devtools.

# 12: Testing your code

Testing is far too important to rely on people to remember to run tests regularly - the testing process has to be automatic.

Unit testing = function testing

Unit testing is performed in the development stage (when the package is being built).

Assertions are executed at run-time: when the function is called.

Unit tests are stored within the tests folder, whilst assertions are within the bodies of functions.

"Notice that I’ve used expect_equivalent() and not expect_equal() to check if expected_df is equal to the output of get_laspeyeres(input_df). This is because expected_df is of class data.frame, while get_laspeyeres() outputs a tibble. So if you use expect_equal() the test would not pass, because the classes of both objects are not strictly equal. Sometimes, this level of strictness is required, but not always, as is the case here."

You can use stopifnot to print error messages.

```{r}
#| label: error-with-stopifnot
#| include: TRUE
#| echo: FALSE
#| error: TRUE

add_one <- function(x) {
  
  stopifnot("x must be a number" = 
              is.numeric(x))
  
  x + 1
  
}

add_one(2)

add_one("2")

```

You can use inherits() to check the type and class of inputs.

"There really is no other way to say this: you need to consider writing tests as an integral part of the project, and need to take the required time it takes to write them into account when planning projects."

# 13: Build automation with targets

"When using a build automation tool, what you end up doing is writing down a recipe that defines how the source code should be “cooked” into the software (or in our case, a report, a cleaned dataset or any data product)."

"We want our pipeline to be a sequence of pure functions."

"Even if you want to compile the document into another format, I advise you to develop using the .html format. This is because you can open the .html file in the web-browser, and keep working on the source. Each time you run the pipeline after you made some changes to the file, you simply need to refresh the web-browser to see your changes."

"A good second reason to have output in the .html format is that HTML is a text-only format, and thus can be tracked with version control systems covered in Chapter 5. The MS Word format is binary, and tracking it in Git is always an undecipherable mess."

I skim-read this chapter as it is beyond my current skill level.

# 14: Docker

"The authors relied on a hidden state (the order of the files) to program their script; in other words, their pipeline was not referentially transparent."

"In very simple (and technically wrong) terms, Docker makes it easy to run a Linux virtual machine (VM) on your computer."

Docker environments are Linux environments. Why Linux? Because reproducibility requires an open-source solution.
